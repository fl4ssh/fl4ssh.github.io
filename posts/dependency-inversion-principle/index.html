<!doctype html><html lang=en><head><title>Dependency Inversion Principle :: Engineering in the wild</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Small overview of Dependency Inversion Principle"><meta name=keywords content=","><meta name=robots content="noodp"><link rel=canonical href=https://fl4ssh.github.io/posts/dependency-inversion-principle/><link rel=stylesheet href=https://fl4ssh.github.io/assets/style.css><link rel=apple-touch-icon href=https://fl4ssh.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://fl4ssh.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Dependency Inversion Principle"><meta property="og:description" content="Small overview of Dependency Inversion Principle"><meta property="og:url" content="https://fl4ssh.github.io/posts/dependency-inversion-principle/"><meta property="og:site_name" content="Engineering in the wild"><meta property="og:image" content="https://fl4ssh.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-05-02 10:37:34 +0600 +0600"></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>fl4ssh</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/showcase>Showcase</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/showcase>Showcase</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://fl4ssh.github.io/posts/dependency-inversion-principle/>Dependency Inversion Principle</a></h1><div class=post-meta><span class=post-date>2023-05-02</span>
<span class=post-author>:: fl4ssh</span></div><span class=post-tags>#<a href=https://fl4ssh.github.io/tags/></a>&nbsp;
#<a href=https://fl4ssh.github.io/tags/></a>&nbsp;</span><div class=post-content><div><h1 id=dependency-inversion-principle>Dependency Inversion Principle<a href=#dependency-inversion-principle class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Dependency Inversion Principle (or DIP) is one of SOLID principles and methodology to avoid highly coupled distribution and increase the re-usability of layer.</p><p>It is different from Dependency Injection, which is used to provide dependency to an application class / layer. Whereas DIP is used to invert the responsibility of flow control in an application.</p><p>Formal definitions of DIP:</p><ul><li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li><li>Abstractions should not depend on details. Instead, details should depend on abstractions.</li></ul><p>Implementing DIP makes your code more flexible, maintainable, and easier to test. It is achieved by decoupling the components of your application by implementing DIP.</p><p>Example of DIP:</p><pre tabindex=0><code>type Repository interface {
    GetData(id int) ([]byte, error) 
}

type Service struct {
    repo Repository
}

func (s *Service) ProcessDataByID(id int) error {
    data, err := s.repo.GetData(id)
    if err != nil {
        return err
    }

    // process data
    return nil
}
</code></pre><p>In this example, we see that the service that processes data by ID is not limited by specific repository implementation, e.g. SQL database, or NoSQL database. All it knows is that it should obtain a data or an error from database. And it is sufficient to work without any issues.</p><p>So DIP is implemented by an abstraction in the face of interfaces in Golang. Let&rsquo;s consider the case that doesn&rsquo;t follow DIP principle:</p><pre tabindex=0><code>type Repository struct {
    db *sql.Conn
}

func (r *Repository) GetData(id int) ([]data, error) {
    // do transaction or simple query to retrieve data
    rows, err := r.Query(&#34;SELECT * FROM table&#34;) 
    if err != nil {
        return nil, error
    }
    // process rows to obtain data, etc...
    return data, nil
}

type Service struct {
    repo *Repository
}

func (s *Service) ProcessDataByID(id int) error {
    data, err := s.repo.GetData(id)
    if err != nil {
        return err
    }

    // process data
    return nil
}
</code></pre><p>In this code example, we see that <code>Service</code> struct directly depends on <code>Repository</code>. To test this code, you will need specific implementation of <code>Repository</code> structure and initialize a connection to a database. This creates unnecessary complexities.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://fl4ssh.github.io/posts/domain-modeling/><span class=button__icon>←</span>
<span class=button__text>Domain Modeling</span></a></span>
<span class="button next"><a href=https://fl4ssh.github.io/posts/starting-competitive-programming/><span class=button__text>Starting Competitive Programming</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://fl4ssh.github.io/assets/main.js></script>
<script src=https://fl4ssh.github.io/assets/prism.js></script></div></body></html>